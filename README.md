# Gstreamer guide

To begin understanding GStreamer, let's first understand its [hello world](https://gstreamer.freedesktop.org/documentation/tutorials/basic/hello-world.html?gi-language=c) code. This will show us how to use an inbuilt end-to-end pipeline - *playbin*. It will introduce the basic concept of [*bus*](https://gstreamer.freedesktop.org/documentation/application-development/basics/bus.html?gi-language=c) and [*message*](https://gstreamer.freedesktop.org/documentation/additional/design/messages.html?gi-language=c) in GStreamer. Messages are lightweight objects to signal the application of pipeline events (ex. state change message, end of stream reached message). A bus is a simple system that takes care of forwarding messages from the streaming threads to an application in its own thread context. Every pipeline contains a bus by default, so applications do not need to create a bus or anything. The only thing applications should do is set a message handler on a bus, which is similar to a signal handler to an object. When the main loop is running, the bus will periodically be checked for new messages, and the callback will be called when any message is available.

   The [basic tutorial 2](https://gstreamer.freedesktop.org/documentation/tutorials/basic/concepts.html?gi-language=c) will help us understand how a custom pipeline is made and how error handling is done. Understand [different states in gstremer](https://gstreamer.freedesktop.org/documentation/plugin-development/basics/states.html?gi-language=c) and how they differ in terms of data flow.
   
   The [basic tutorial 3](https://gstreamer.freedesktop.org/documentation/tutorials/basic/dynamic-pipelines.html?gi-language=c) will have us to understand the concept of pads. Basically, all the elements have pads which facilitate the data flow from one element to another. There are two types of pads- source and sink. A pad can have three types of availability- always, sometimes, and on request. Always type pads are the default pads available to every element when it's created. Sometimes type pads are made by an element (like a demuxer) during run time as per the different varieties of data flowing through it. Request pads are basically the extra pads that are created as per the user demand in the start itself. We can learn about them in more detail over [here](https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html?gi-language=c). In this tutorial, we learn how to handle *sometimes* type of pad.  A major takeaway from this tutorial is to understand how various streams contained in the same file can be handled using dynamic linking of pads.
   
   Now we can proceed to [basic tutorial 4](https://gstreamer.freedesktop.org/documentation/tutorials/basic/time-management.html?gi-language=c). Main takeaway of this code will be to understand how to perform seek to anytime using the function [gst_element_seek_simple](https://gstreamer.freedesktop.org/documentation/gstreamer/gstelement.html?gi-language=c#gst_element_seek_simple) and how to query the current position and duration of the stream using functions [gst_element_query_position](https://gstreamer.freedesktop.org/documentation/gstreamer/gstelement.html?gi-language=c#gst_element_query_position) and [gst_element_query_duration](https://gstreamer.freedesktop.org/documentation/gstreamer/gstelement.html?gi-language=c#gst_element_query_duration) respectively. It also introduces us to the concept of [GstQuery](https://gstreamer.freedesktop.org/documentation/gstreamer/gstquery.html?gi-language=c), which has a wider use to query different information about an element or a pad. 
   
   As of now, the main thing to notice is that any GStreamer application uses lots of callback functions for various purposes (bus watching, pad linking, etc.). These callback functions are timely called using the concept of [signals](https://gstreamer.freedesktop.org/documentation/plugin-development/basics/signals.html?gi-language=c). Different signals are generated whenever any interesting event happens to any of the objects. These signals can then help us to evoke call-back functions to carry out certain tasks. Now here comes the role of [gmain loop](https://www.freedesktop.org/software/gstreamer-sdk/data/docs/latest/glib/glib-The-Main-Event-Loop.html). It continuously checks for new events from each of the event sources and dispatches them.
   
   Then we can proceed to [basic tutorial 6](https://gstreamer.freedesktop.org/documentation/tutorials/basic/media-formats-and-pad-capabilities.html?gi-language=c) to understand the concept of pad capabilities. Pad capabilities basically tell us the requirements to be met by any inflowing data through that pad, or what is the format in which data would be outputted through the pad. So every two pads that are going to get linked in the pipeline must have a common subset of requirements from data flow to happen; else, they would be termed incompatible with each other.
   
   [Basic tutorial 7](https://gstreamer.freedesktop.org/documentation/tutorials/basic/multithreading-and-pad-availability.html?gi-language=c) introduces us to tee element. The purpose of this element is that it helps us to replicate a stream. It also explains to us about *request pads*, which can create on user request. It shows us how to create a pad in an element and link two pads manually suing the functions like [gst_element_get_static_pad](https://gstreamer.freedesktop.org/documentation/gstreamer/gstelement.html?gi-language=c#gst_element_get_static_pad), [gst_element_get_request_pad](https://gstreamer.freedesktop.org/documentation/gstreamer/gstelement.html?gi-language=c#gst_element_get_request_pad) and [gst_pad_link](https://gstreamer.freedesktop.org/documentation/gstreamer/gstpad.html?gi-language=c#gst_pad_link).
  
   [Basic tutorial 8](https://gstreamer.freedesktop.org/documentation/tutorials/basic/short-cutting-the-pipeline.html?gi-language=c) will then explain to us how we can import and export data out of the GStreamer to any other file or application. It introduces us with *appsrc* and *appsink* elements. *Appsrc* is useful to inject data in the middle of a GStreamer pipeline (say NLP program generated captions), which we probably didn't have at the start of the pipeline due to any reasons. *Appsink* will help us to export data (say audio to an NLP program) out of the GStreamer to any other application of file.
   
   [Basic tutorial 9](https://gstreamer.freedesktop.org/documentation/tutorials/basic/media-information-gathering.html?gi-language=c) is optional. It teaches us how to fetch information regarding a given URI beforehand for making certain appropriate decisions if we wish to.
    
   [Basic tutorial 10](https://gstreamer.freedesktop.org/documentation/tutorials/basic/gstreamer-tools.html?gi-language=c) teaches us how to make a very basic pipeline through the command line itself. Though not useful in actual development, it might be useful for testing.
    
   [Basic tutorial 12](https://gstreamer.freedesktop.org/documentation/tutorials/basic/streaming.html?gi-language=c) help us to know how to we can manage buffering in GStreamer. Various types of buffering available are explained in more detail over [here](https://gstreamer.freedesktop.org/documentation/application-development/advanced/buffering.html?gi-language=cgstreamer%20buufering)
   
